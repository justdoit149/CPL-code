思路：


函数使用：
1.bool check_parentheses(int l, int r);
    此函数用于判断该表达式是否是一个被完整的、匹配的括号包括的表达式，两个参数l、r分别指示首尾
    如果是，那么返回值为1；否，则返回0；
    如果是的话，将在接下来的操作中把两端的括号去掉，求中间的表达式的值（非本函数完成）（即（l+1,r-1））
    （2 + 3 * （5 + 7））是；（2 + 3）*（4 - 3）不是（因为两端括号不匹配），2 * （2 + 3）不是（因为两端没括号）
    实现思路：（由于这个要递归，所以要尽可能快）（时间复杂度：max = o(n)）
        先看首尾，如果不是括号直接返回0
        如果是的话，初始一个index变量为1，从l+1开始向后遍历，遇到"（"则index加1，"）"则index减1
        直到index为0的时候停止，如果这时候遍历到了r，那么返回1，如果还没到r,则返回0.

2.Value eval (int l,int r);
    此函数用于对从l到r的表达式求值。采用递归，把一个表达式拆成两个小的表达式，直到最终每个长度都为1（0：非法）
    （由于不知道返回值是整型还是浮点型，故用union结构来实现。